const InputView = require('./input-view')
const githubApi = require('./github-api')
const config = require('./config')

const notify = {
	gist: githubApi.gists,

	busySignal: null,
	busySignals: [],

	fatal: (...args) => atom.notifications.addFatalError(...args),
	error: (...args) => atom.notifications.addError(...args),
	warning: (...args) => atom.notifications.addWarning(...args),
	info: (...args) => atom.notifications.addInfo(...args),
	success: (...args) => atom.notifications.addSuccess(...args),

	useBusySignal (busySignal) {
		this.busySignal = busySignal
	},

	disposeBusySignal () {
		this.busySignal = null
		this.busySignals.forEach(b => b.dispose())
		this.busySignals = []
	},

	signal (msg, options = {}) {
		if (!this.busySignal) {
			if (options.promise) {
				return options.promise
			} else {
				return { dismiss () {} }
			}
		}

		const busySignalOpts = {
			revealTooltip: ('revealTooltip' in options) ? !!options.revealTooltip : true,
		}
		if (options.onlyForFile) {
			busySignalOpts.onlyForFile = options.onlyForFile
		}
		if (options.waitingFor) {
			busySignalOpts.waitingFor = options.waitingFor
		}
		if (options.onDidClick) {
			busySignalOpts.onDidClick = options.onDidClick
		}
		if ('append' in options && !options.append) {
			this.busySignals.forEach(b => b.dispose())
			this.busySignals = []
		}

		if (options.promise) {
			return this.busySignal.reportBusyWhile(msg, () => options.promise, busySignalOpts)
		} else {
			const signal = this.busySignal.reportBusy(msg, busySignalOpts)
			this.busySignals.push(signal)
			return { dismiss () { signal.dispose() } }
		}
	},

	count (msg, num, total) {
		if (!this.busySignal) {
			return this.info(`${msg} (${num}/${total})`, { dismissable: true })
		}

		return this.signal(`${msg} (${num}/${total})`, { revealTooltip: false })
	},

	warnBackupConfig () {
		const notification = this.warning('sync-settings: Backing up `config.cson` is risky.', {
			description: `
Sync-Settings should already backup your settings.
\`config.cson\` contains your Personal Access Token.
You can store it in the environment variable \`GITHUB_TOKEN\`.

Do you want to back up this file anyway?`.trim(),
			dismissable: true,
			buttons: [{
				text: 'Backup Anyway',
				onDidClick () {
					notification.dismiss()
					atom.config.set('sync-settings.warnBackupConfig', false)
					atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
				},
			}],
		})
	},

	invalidGistId (retryFn, invalidGistId) {
		const notification = this.error(invalidGistId ? 'Invalid Gist ID' : 'No Gist ID', {
			description: invalidGistId
				? `No Gist found at with ID [\`${invalidGistId}\`](https://gist.github.com/${invalidGistId})`
				: 'No Gist ID found in settings or `GIST_ID`',
			dismissable: true,
			buttons: [{
				text: 'Enter Gist ID',
				async onDidClick () {
					notification.dismiss()
					const inputView = new InputView({
						title: 'Enter Gist ID',
						description: 'You can create a new Gist at [gist.github.com](https://gist.github.com/). You should create a secret gist.',
						placeholder: 'Gist ID',
						value: invalidGistId,
					})
					const gistId = await inputView.getInput()
					if (gistId) {
						atom.config.set('sync-settings.gistId', gistId)
						if (typeof retryFn === 'function') {
							retryFn(gistId)
						}
					}
				},
			}, {
				text: 'Create New Gist',
				async onDidClick () {
					notification.dismiss()
					const signal = notify.signal('sync-settings: Creating gist...')
					let res
					try {
						res = await notify.gist.create(config.getPersonalAccessToken(), {
							public: false,
							description: atom.config.get('sync-settings.gistDescription'),
							files: { README: { content: '# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>' } },
						})
					} catch (err) {
						notify.error('Error Creating Gist', {
							dismissable: true,
							detail: githubApi.errorMessage(err),
						})
						return
					} finally {
						signal.dismiss()
					}
					if (githubApi.invalidRes(res, [['data', 'id']])) {
						console.error('could not interpret result:', res)
						notify.error('sync-settings: Error creating gist')
					}
					atom.config.set('sync-settings.gistId', res.data.id)
					if (typeof retryFn === 'function') {
						retryFn(res.data.id)
					}
				},
			}, {
				text: 'Package settings',
				onDidClick () {
					notification.dismiss()
					atom.workspace.open('atom://config/packages/sync-settings')
				},
			}],
		})
	},

	invalidPersonalAccessToken (retryFn, invalidPersonalAccessToken) {
		const notification = this.error(`${invalidPersonalAccessToken ? 'Invalid' : 'No'} Personal Access Token`, {
			description: `
${invalidPersonalAccessToken ? 'Invalid' : 'No'} Personal Access Token found in settings or \`GITHUB_TOKEN\`

Create a [new personal access token](https://github.com/settings/tokens/new?scopes=gist)
and set the environment variable \`GITHUB_TOKEN\` or enter it in the settings.`.trim(),
			dismissable: true,
			buttons: [{
				text: 'Enter Personal Access Token',
				async onDidClick () {
					notification.dismiss()
					const inputView = new InputView({
						title: 'Enter Personal Access Token',
						description: 'If you create a [new Personal Access Token](https://github.com/settings/tokens/new?scopes=gist) make sure it has `gists` permission.',
						placeholder: 'Personal Access Token',
						value: invalidPersonalAccessToken,
					})
					const personalAccessToken = await inputView.getInput()
					if (personalAccessToken) {
						atom.config.set('sync-settings.personalAccessToken', personalAccessToken)
						if (typeof retryFn === 'function') {
							retryFn(personalAccessToken)
						}
					}
				},
			}, {
				text: 'Package settings',
				onDidClick () {
					notification.dismiss()
					atom.workspace.open('atom://config/packages/sync-settings')
				},
			}],
		})
	},

	newerBackup (autoCheck) {
		const buttons = [{
			text: 'Backup',
			onDidClick () {
				notification.dismiss()
				atom.commands.dispatch(workspaceElement, 'sync-settings:backup')
			},
		}, {
			text: 'View Backup',
			onDidClick () {
				atom.commands.dispatch(workspaceElement, 'sync-settings:view-backup')
			},
		}, {
			text: 'View Diff',
			onDidClick () {
				notification.dismiss()
				atom.commands.dispatch(workspaceElement, 'sync-settings:view-diff')
			},
		}, {
			text: 'Restore',
			onDidClick () {
				notification.dismiss()
				atom.commands.dispatch(workspaceElement, 'sync-settings:restore')
			},
		}]

		if (autoCheck) {
			buttons.push({
				text: 'Stop Automatic Check',
				onDidClick () {
					notification.dismiss()
					atom.config.set('sync-settings.checkForUpdatedBackup', false)
				},
			})
		}
		// we need the actual element for dispatching on it
		const workspaceElement = atom.views.getView(atom.workspace)
		const notification = this.warning('sync-settings: Your settings are out of date.', {
			dismissable: true,
			buttons,
		})
	},
}

module.exports = notify
