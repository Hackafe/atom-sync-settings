/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
const SyncSettings = require('../lib/sync-settings');
const SpecHelper = require('./spec-helpers');
const run = SpecHelper.callAsync;
const fs = require('fs');
const path = require('path');
const os = require('os');
// Use the command `window:run-package-specs` (cmd-alt-ctrl-p) to run specs.
//
// To run a specific `it` or `describe` block add an `f` to the front (e.g. `fit`
// or `fdescribe`). Remove the `f` to unfocus the block.

describe("SyncSettings", function() {

  describe("low-level", () => describe("::fileContent", function() {
    const tmpPath = path.join(os.tmpdir(), 'atom-sync-settings.tmp');

    it("returns null for not existing file", () => expect(SyncSettings.fileContent(tmpPath)).toBeNull());

    it("returns null for empty file", function() {
      fs.writeFileSync(tmpPath, "");
      try {
        return expect(SyncSettings.fileContent(tmpPath)).toBeNull();
      } finally {
        fs.unlinkSync(tmpPath);
      }
    });

    return it("returns content of existing file", function() {
      const text = "alabala portocala";
      fs.writeFileSync(tmpPath, text);
      try {
        return expect(SyncSettings.fileContent(tmpPath)).toEqual(text);
      } finally {
        fs.unlinkSync(tmpPath);
      }
    });
  }));

  return describe("high-level", function() {
    const TOKEN_CONFIG = 'sync-settings.personalAccessToken';
    const GIST_ID_CONFIG = 'sync-settings.gistId';

    window.resetTimeouts();
    SyncSettings.activate();
    window.advanceClock();

    beforeEach(function() {
      this.token = process.env.GITHUB_TOKEN || atom.config.get(TOKEN_CONFIG);
      atom.config.set(TOKEN_CONFIG, this.token);

      return run(function(cb) {
        const gistSettings = {
          public: false,
          description: "Test gist by Sync Settings for Atom https://github.com/atom-community/sync-settings",
          files: { README: {content: '# Generated by Sync Settings for Atom https://github.com/atom-community/sync-settings'}
        }
        };
        return SyncSettings.createClient().gists.create(gistSettings).then(a => cb(null, a), cb);
      }
      , (err, res) => {
        expect(err).toBeNull();

        this.gistId = res.data.id;
        console.log(`Using Gist ${this.gistId}`);
        return atom.config.set(GIST_ID_CONFIG, this.gistId);
      });
    });

    afterEach(function() {
      return run(cb => {
        return SyncSettings.createClient().gists.delete({gist_id: this.gistId}).then(a => cb(null, a), cb);
      }
      , (err, res) => expect(err).toBeNull());
    });

    describe("::backup", function() {
      it("back up the settings", function() {
        atom.config.set('sync-settings.syncSettings', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['settings.json']).toBeDefined());
        });
      });

      it("don't back up the settings", function() {
        atom.config.set('sync-settings.syncSettings', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['settings.json']).not.toBeDefined());
        });
      });

      it("back up the installed packages list", function() {
        atom.config.set('sync-settings.syncPackages', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['packages.json']).toBeDefined());
        });
      });

      it("don't back up the installed packages list", function() {
        atom.config.set('sync-settings.syncPackages', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['packages.json']).not.toBeDefined());
        });
      });

      it("back up the user keymaps", function() {
        atom.config.set('sync-settings.syncKeymap', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['keymap.cson']).toBeDefined());
        });
      });

      it("don't back up the user keymaps", function() {
        atom.config.set('sync-settings.syncKeymap', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['keymap.cson']).not.toBeDefined());
        });
      });

      it("back up the user styles", function() {
        atom.config.set('sync-settings.syncStyles', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['styles.less']).toBeDefined());
        });
      });

      it("don't back up the user styles", function() {
        atom.config.set('sync-settings.syncStyles', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['styles.less']).not.toBeDefined());
        });
      });

      it("back up the user init script file", function() {
        atom.config.set('sync-settings.syncInit', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files[path.basename(atom.getUserInitScriptPath())]).toBeDefined());
        });
      });

      it("don't back up the user init script file", function() {
        atom.config.set('sync-settings.syncInit', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files[path.basename(atom.getUserInitScriptPath())]).not.toBeDefined());
        });
      });

      it("back up the user snippets", function() {
        atom.config.set('sync-settings.syncSnippets', true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['snippets.cson']).toBeDefined());
        });
      });

      it("don't back up the user snippets", function() {
        atom.config.set('sync-settings.syncSnippets', false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(res.data.files['snippets.cson']).not.toBeDefined());
        });
      });

      it("back up the files defined in config.extraFiles", function() {
        atom.config.set('sync-settings.extraFiles', ['test.tmp', 'test2.tmp']);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => Array.from(atom.config.get('sync-settings.extraFiles')).map((file) =>
            expect(res.data.files[file]).toBeDefined()));
        });
      });

      return it("don't back up extra files defined in config.extraFiles", function() {
        atom.config.set('sync-settings.extraFiles', undefined);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          return run(cb => {
            return SyncSettings.createClient().gists.get({gist_id: this.gistId}).then(a => cb(null, a), cb);
          }
          , (err, res) => expect(Object.keys(res.data.files).length).toBe(1));
        });
      });
    });

    describe("::restore", function() {
      it("updates settings", function() {
        atom.config.set('sync-settings.syncSettings', true);
        atom.config.set("some-dummy", true);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          atom.config.set("some-dummy", false);
          return run(cb => SyncSettings.restore(cb)
          , () => expect(atom.config.get("some-dummy")).toBeTruthy());
        });
      });

      it("doesn't updates settings", function() {
        atom.config.set('sync-settings.syncSettings', false);
        atom.config.set("some-dummy", true);
        return run(cb => SyncSettings.backup(cb)
        , () => run(cb => SyncSettings.restore(cb)
        , () => expect(atom.config.get("some-dummy")).toBeTruthy()));
      });

      it("overrides keymap.cson", function() {
        let left;
        atom.config.set('sync-settings.syncKeymap', true);
        const original = (left = SyncSettings.fileContent(atom.keymaps.getUserKeymapPath())) != null ? left : "# keymap file (not found)";
        return run(cb => SyncSettings.backup(cb)
        , function() {
          fs.writeFileSync(atom.keymaps.getUserKeymapPath(), `${original}\n# modified by sync setting spec`);
          return run(cb => SyncSettings.restore(cb)
          , function() {
            expect(SyncSettings.fileContent(atom.keymaps.getUserKeymapPath())).toEqual(original);
            return fs.writeFileSync(atom.keymaps.getUserKeymapPath(), original);
          });
        });
      });

      it("restores all other files in the gist as well", function() {
        atom.config.set('sync-settings.extraFiles', ['test.tmp', 'test2.tmp']);
        return run(cb => SyncSettings.backup(cb)
        , () => run(cb => SyncSettings.restore(cb)
        , () => (() => {
          const result = [];
          for (let file of Array.from(atom.config.get('sync-settings.extraFiles'))) {
            expect(fs.existsSync(`${atom.getConfigDirPath()}/${file}`)).toBe(true);
            expect(SyncSettings.fileContent(`${atom.getConfigDirPath()}/${file}`)).toBe(`# ${file} (not found) `);
            result.push(fs.unlink(`${atom.getConfigDirPath()}/${file}`, function() {}));
          }
          return result;
        })()));
      });

      it("skips the restore due to invalid json", function() {
        atom.config.set('sync-settings.syncSettings', true);
        atom.config.set('sync-settings.extraFiles', ['packages.json']);
        atom.config.set("some-dummy", false);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          atom.config.set("some-dummy", true);
          atom.notifications.clear();

          return run(cb => SyncSettings.restore(cb)
          , function() {
            expect(atom.notifications.getNotifications().length).toEqual(1);
            expect(atom.notifications.getNotifications()[0].getType()).toBe('error');
            // the value should not be restored
            // since the restore valid to parse the input as valid json
            return expect(atom.config.get("some-dummy")).toBeTruthy();
          });
        });
      });

      return it("restores keys with dots", function() {
        atom.config.set('sync-settings.syncSettings', true);
        atom.config.set('some\\.key', ['one', 'two']);
        return run(cb => SyncSettings.backup(cb)
        , function() {
          atom.config.set("some\\.key", ['two']);

          return run(cb => SyncSettings.restore(cb)
          , function() {
            expect(atom.config.get("some\\.key").length).toBe(2);
            expect(atom.config.get("some\\.key")[0]).toBe('one');
            return expect(atom.config.get("some\\.key")[1]).toBe('two');
          });
        });
      });
    });

    return describe("::check for update", function() {

      beforeEach(() => atom.config.unset('sync-settings._lastBackupHash'));

      it("updates last hash on backup", () => run(cb => SyncSettings.backup(cb)
      , () => expect(atom.config.get("sync-settings._lastBackupHash")).toBeDefined()));

      it("updates last hash on restore", () => run(cb => SyncSettings.restore(cb)
      , () => expect(atom.config.get("sync-settings._lastBackupHash")).toBeDefined()));

      return describe("::notification", function() {
        beforeEach(() => atom.notifications.clear());

        it("displays on newer backup", () => run(cb => SyncSettings.checkForUpdate(cb)
        , function() {
          expect(atom.notifications.getNotifications().length).toBe(1);
          return expect(atom.notifications.getNotifications()[0].getType()).toBe('warning');
        }));

        return it("ignores on up-to-date backup", () => run(cb => SyncSettings.backup(cb)
        , () => run(function(cb) {
          atom.notifications.clear();
          return SyncSettings.checkForUpdate(cb);
        }
        , function() {
          expect(atom.notifications.getNotifications().length).toBe(1);
          return expect(atom.notifications.getNotifications()[0].getType()).toBe('success');
        })));
      });
    });
  });
});
