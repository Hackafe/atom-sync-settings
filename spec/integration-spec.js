const syncSettings = require('../lib/main')
const githubApi = require('../lib/github-api')
const SyncSettings = require('../lib/sync-settings')
const fs = require('fs')
const util = require('util')
const writeFile = util.promisify(fs.writeFile)
const readFileAsync = util.promisify(fs.readFile)
const readFile = (file) => readFileAsync(file, { encoding: 'utf8' })
const unlink = util.promisify(fs.unlink)
const path = require('path')

describe('integration', () => {
	it('should activate and deactivate without error', async () => {
		atom.config.set('sync-settings.checkForUpdatedBackup', false)
		spyOn(console, 'error').and.callThrough()
		await atom.packages.activatePackage('sync-settings')
		// wait for package to activate
		await syncSettings.activationPromise
		await atom.packages.deactivatePackage('sync-settings')

		expect(console.error).not.toHaveBeenCalled()
	})

	it('should check backup on activation', async () => {
		spyOn(SyncSettings.prototype, 'checkForUpdate')
		await atom.packages.activatePackage('sync-settings')
		await syncSettings.activationPromise

		expect(SyncSettings.prototype.checkForUpdate).toHaveBeenCalled()

		await atom.packages.deactivatePackage('sync-settings')
	})

	describe('commands', () => {
		beforeEach(async () => {
			atom.config.set('sync-settings.checkForUpdatedBackup', false)
			await atom.packages.activatePackage('sync-settings')
			await syncSettings.activationPromise
		})

		afterEach(async () => {
			await atom.packages.deactivatePackage('sync-settings')
		})

		it('backup', async () => {
			spyOn(SyncSettings.prototype, 'backup')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')

			expect(SyncSettings.prototype.backup).toHaveBeenCalled()
		})

		it('restore', async () => {
			spyOn(SyncSettings.prototype, 'restore')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')

			expect(SyncSettings.prototype.restore).toHaveBeenCalled()
		})

		it('view backup', async () => {
			spyOn(SyncSettings.prototype, 'viewBackup')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:view-backup')

			expect(SyncSettings.prototype.viewBackup).toHaveBeenCalled()
		})

		it('check backup', async () => {
			spyOn(SyncSettings.prototype, 'checkForUpdate')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:check-backup')

			expect(SyncSettings.prototype.checkForUpdate).toHaveBeenCalled()
		})

		it('fork backup', async () => {
			spyOn(SyncSettings.prototype, 'inputForkGistId')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:fork')

			expect(SyncSettings.prototype.inputForkGistId).toHaveBeenCalled()
		})
	})

	// FIXME: not sure why linux api test is timing out
	if (process.env.GITHUB_TOKEN && process.platform !== 'linux') {
		describe('API', () => {
			let token, gistId
			beforeEach(async () => {
				await writeFile(atom.keymaps.getUserKeymapPath(), '# keymap')
				await writeFile(atom.styles.getUserStyleSheetPath(), '// stylesheet')
				await writeFile(atom.getUserInitScriptPath(), '# init')
				await writeFile(path.resolve(atom.getConfigDirPath(), 'snippets.cson'), '# snippets')
				token = process.env.GITHUB_TOKEN || atom.config.get('sync-settings.personalAccessToken')
				atom.config.set('sync-settings.personalAccessToken', token)
				const gistSettings = {
					public: false,
					description: 'Test gist by Sync Settings for Atom https://github.com/atom-community/sync-settings',
					files: { README: { content: '# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>' } },
				}

				const res = await githubApi.gists.create(token, gistSettings)
				gistId = res.data.id
				atom.config.set('sync-settings.gistId', gistId)
				await atom.packages.activatePackage('sync-settings')
				await syncSettings.activationPromise
			})

			afterEach(async () => {
				await githubApi.gists.delete(token, { gist_id: gistId })
				await atom.packages.deactivatePackage('sync-settings')
				await unlink(atom.keymaps.getUserKeymapPath())
				await unlink(atom.styles.getUserStyleSheetPath())
				await unlink(atom.getUserInitScriptPath())
				await unlink(path.resolve(atom.getConfigDirPath(), 'snippets.cson'))
			})

			it('backs up files', async () => {
				atom.config.set('sync-settings.gistDescription', 'automatic update by http://atom.io/packages/sync-settings')
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
				const gist = await githubApi.gists.get(token, { gist_id: gistId })
				expect(gist).toEqual(jasmine.objectContaining({
					status: 200,
					url: jasmine.stringMatching(/^https:\/\/api\.github\.com\/gists/),
					headers: jasmine.any(Object),
					data: jasmine.objectContaining({
						id: jasmine.stringMatching(/^\w+$/),
						public: false,
						description: 'automatic update by http://atom.io/packages/sync-settings',
						html_url: jasmine.stringMatching(/^https:\/\/gist\.github\.com/),
						history: [
							jasmine.objectContaining({
								version: jasmine.stringMatching(/^\w+$/),
							}),
							jasmine.objectContaining({
								version: jasmine.stringMatching(/^\w+$/),
							}),
						],
						files: {
							README: jasmine.objectContaining({
								content: '# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>',
								filename: 'README',
							}),
							'init.coffee': jasmine.objectContaining({
								content: '# init',
								filename: 'init.coffee',
							}),
							'keymap.cson': jasmine.objectContaining({
								content: '# keymap',
								filename: 'keymap.cson',
							}),
							'packages.json': jasmine.objectContaining({
								content: jasmine.stringMatching(/about/),
								filename: 'packages.json',
							}),
							'settings.json': jasmine.objectContaining({
								content: jasmine.stringMatching(/"sync-settings":/),
								filename: 'settings.json',
							}),
							'snippets.cson': jasmine.objectContaining({
								content: '# snippets',
								filename: 'snippets.cson',
							}),
							'styles.less': jasmine.objectContaining({
								content: '// stylesheet',
								filename: 'styles.less',
							}),
						},
					}),
				}))
			}, 10 * 1000)

			it('restores files', async () => {
				atom.config.set('sync-settings.extraFiles', ['README'])
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')
				const readme = await readFile(path.resolve(atom.getConfigDirPath(), 'README'))

				expect(readme).toBe('# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>')
			}, 10 * 1000)

			it('backs up and restores paths with slash', async () => {
				atom.config.set('sync-settings.extraFiles', ['../test.tmp'])
				const tmpPath = path.resolve(atom.getConfigDirPath(), '../test.tmp')
				await writeFile(tmpPath, 'test.tmp')
				try {
					await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
					await unlink(tmpPath)
					await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')
					const content = await readFile(tmpPath)

					expect(content).toBe('test.tmp')
				} finally {
					await unlink(tmpPath)
				}
			}, 10 * 1000)

			it('does not delete a file with only whitespace', async () => {
				atom.config.set('sync-settings.extraFiles', ['README'])
				await writeFile(path.resolve(atom.getConfigDirPath(), 'README'), '\n \t')
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
				const gist = await githubApi.gists.get(token, { gist_id: gistId })
				expect('README' in gist.data.files).toBe(true)
				expect(gist.data.files.README.content).toContain('(not found)')
			}, 10 * 1000)
		})
	}
})
